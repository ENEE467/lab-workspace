#include "lab8/ur3e_move_interface.hpp"

void UR3eMoveInterface::examplesMoveIt()
{
  /**
   * Based on MoveIt Documentation - Move Group C++ Interface
   *
   * Use the content inside this function as a reference and learn about using
   * the MoveGroup Interface to move the UR3e manipulator.
   *
   * MoveIt! API lets you move the robotic arm in three ways:
   *  - By commanding target joint angles
   *  - By commanding waypoints through which the end-effector has to go
   *  - By commanding a pose target of the end-effector
   *
   * Use these methods to draw shapes with the robotic arm.
   */
  RCLCPP_INFO(this->get_logger(), "Running examples...");

  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * EXAMPLE 1 - Move the robot to specific joint positions.
   *
   * Step 1: Define a vector of doubles to specify your joint positions in radians.
   * Step 2: Set the target joint angles to the arm.
   * Step 3: Plan the motion to target joint angles.
   * Step 4: Move the robotic arm!
   */
  RCLCPP_INFO(this->get_logger(), "Example 1");

  // Step 1
  std::vector<double> target_joint_positions {M_PI_2, -M_PI_2, M_PI_2, -M_PI, -M_PI_2, 0};

  // Step 2
  move_group_interface_->setJointValueTarget(target_joint_positions);

  // Step 3
  moveit::planning_interface::MoveGroupInterface::Plan motion_plan_joints;
  bool joint_space_plan_success {planToJointSpaceGoal(target_joint_positions, motion_plan_joints)};

  // Step 4
  if (joint_space_plan_success)
    move_group_interface_->execute(motion_plan_joints);

  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * EXAMPLE 2 - Move the robot through end-effector waypoints to draw a triangle.
   *
   * Step 1: Define waypoints for the end-effector - A vector of pose messages.
   * Step 2: Add the current end-effector pose as the first waypoint.
   * Step 3: Add the remaining waypoints relative to the first waypoint.
   * Step 4: Define an empty message to store the trajectory generated by planner.
   * Step 5: Plan the path.
   * Step 6: Move the robotic arm!
   */
  RCLCPP_INFO(this->get_logger(), "Example 2");

  // Step 1
  std::vector<geometry_msgs::msg::Pose> waypoints;

  // Step 2
  auto current_pose = move_group_interface_->getCurrentPose().pose;
  waypoints.push_back(current_pose);

  double triangle_side {0.25};

  // Step 3
  auto pose1 = current_pose;
  pose1.position.z += std::sqrt(3) * 0.25 * triangle_side;
  waypoints.push_back(pose1);

  auto pose2 = pose1;
  pose2.position.z -= std::sqrt(3) * 0.5 * triangle_side;
  pose2.position.y += 0.5 * triangle_side;
  waypoints.push_back(pose2);

  auto pose3 = pose2;
  pose3.position.y -= triangle_side;
  waypoints.push_back(pose3);

  auto pose4 = pose3;
  pose4.position.z += std::sqrt(3) * 0.5 * triangle_side;
  pose4.position.y += 0.5 * triangle_side;
  waypoints.push_back(pose4);

  auto pose5 = pose4;
  pose5.position.z -= std::sqrt(3) * 0.25 * triangle_side;
  waypoints.push_back(pose5);

  // Step 4
  moveit_msgs::msg::RobotTrajectory cartesian_trajectory;

  // Step 5
  bool cartesian_plan_success {planCartesianPath(waypoints, cartesian_trajectory)};

  // Additional Step: Create and send a track request to start tracking the end-effector pose
  auto track_request {std::make_shared<lab8::srv::TrackRequest::Request>()};

  track_request->tf_root_frame_name = move_group_interface_->getPlanningFrame();
  track_request->tf_tip_frame_name = move_group_interface_->getEndEffectorLink();

  track_request->plot_title = "Example: A Triangle in the vertical plane";
  track_request->plot_axis_x = lab8::srv::TrackRequest::Request::Y_AXIS;
  track_request->plot_axis_y = lab8::srv::TrackRequest::Request::Z_AXIS;

  track_request->status = lab8::srv::TrackRequest::Request::START;

  bool track_request_success {sendEEFTrackRequest(track_request)};

  // Step 6
  if (cartesian_plan_success && track_request_success)
    move_group_interface_->execute(cartesian_trajectory);

  // Stop tracking the end effector by sending a STOP request.
  track_request->status = lab8::srv::TrackRequest::Request::STOP;
  sendEEFTrackRequest(track_request);

  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * EXAMPLE 3 - Move the robot to a specific end-effector pose.
   *
   * Step 1: Define a message that stores the target end-effector pose in world frame.
   * Step 2: Set the target end-effector pose message using either relative or absolute values.
   * Step 3: Set the target pose using the message.
   * Step 4: Move the robotic arm!
   */
  RCLCPP_INFO(this->get_logger(), "Example 3");

  // Step 1
  geometry_msgs::msg::Pose target_pose;

  // Step 2 - Setting the target displacement relative to current displacement. (Commented out for now)
  target_pose = move_group_interface_->getCurrentPose().pose;
  // target_pose.position.z += 0.05;
  // target_pose.position.y += 0.1;

  /**
   * Step 2 Continuation - Setting the target orientation relative to current orientation.
   *
   * Steps to rotate the end-effector by a certain value:
   * - Obtain the current orientation and convert it to TF2 Quaternion message
   * - Create an empty TF2 Quaternion message
   * - Set the rotation as desired using roll-pitch-yaw angles
   * - Apply the rotation by pre-multiplying with the current orientation quaternion
   * - Convert the TF2 quaternion message back to geometry message with the new
   *   orientation encoded into the target pose.
   *
   * In short, TF2 quaternions are used as an intermediate datatype to do
   * rotation math since geometry quaternions do not have that functionality.
   */
  tf2::Quaternion current_orientation_tf;
  tf2::convert(target_pose.orientation, current_orientation_tf);

  tf2::Quaternion desired_rotation_tf;
  desired_rotation_tf.setRPY(0, -M_PI_2, 0);

  auto target_orientation_tf = desired_rotation_tf * current_orientation_tf;
  tf2::convert(target_orientation_tf, target_pose.orientation);

  // Step 3
  move_group_interface_->setPoseTarget(target_pose);

  // Step 4
  move_group_interface_->move();

  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * EXAMPLE 4 - Moving the robot to a named, predefined position.
   *
   * All the predefined positions are defined in lab.srdf from the lab_moveit_config package in
   * joint space.
   */
  move_group_interface_->setNamedTarget("up");
  move_group_interface_->move();
}
