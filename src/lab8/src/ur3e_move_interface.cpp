#include <tf2/LinearMath/Quaternion.h>

#include "lab8/ur3e_move_interface.hpp"

UR3eMoveInterface::UR3eMoveInterface(const rclcpp::NodeOptions& node_options)
: Node {"ur3e_move_interface", node_options},
  move_group_interface_ {std::make_shared<moveit::planning_interface::MoveGroupInterface>(
    rclcpp::Node::SharedPtr(std::move(this)), "ur_manipulator")}
{
  RCLCPP_INFO(this->get_logger(), "Initializing move group node...");
  move_group_interface_->setMaxVelocityScalingFactor(velocity_scaling_factor_);
  move_group_interface_->setMaxAccelerationScalingFactor(acceleration_scaling_factor_);

  if (move_group_interface_->startStateMonitor(3))
    move_group_interface_initialized_ = true;

  RCLCPP_INFO(this->get_logger(), "Waiting for end-effector tracking service");
  track_eef_client_ = this->create_client<lab8::srv::TrackRequest>("track_eef");
  tracking_service_available_ = track_eef_client_->wait_for_service(std::chrono::seconds(3));

  if (!tracking_service_available_)
    RCLCPP_WARN(this->get_logger(), "Tracking service is unavailable, poses cannot be saved/plotted.");
}

void UR3eMoveInterface::examplesMoveIt()
{
  waitForMoveGroupInterface();

  /**
   * Based on MoveIt Documentation - Move Group C++ Interface
   *
   * Use the content inside this function as a reference and learn about using
   * the MoveGroup Interface to move the UR3e manipulator.
   *
   * MoveIt! API lets you move the robotic arm in three ways:
   *  - By commanding target joint angles
   *  - By commanding waypoints through which the end-effector has to go
   *  - By commanding a pose target of the end-effector
   *
   * Use these methods to draw shapes with the robotic arm.
   */
  RCLCPP_INFO(this->get_logger(), "Running examples...");

  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * EXAMPLE 1 - Move the robot to specific joint positions.
   *
   * Step 1: Define a vector of doubles to specify your joint positions in radians.
   * Step 2: Set the target joint angles to the arm.
   * Step 3: Plan the motion to target joint angles.
   * Step 4: Move the robotic arm!
   */
  RCLCPP_INFO(this->get_logger(), "Example 1");

  // Step 1
  std::vector<double> target_joint_positions {M_PI_2, -M_PI_2, M_PI_2, -M_PI, -M_PI_2, 0};

  // Step 2
  move_group_interface_->setJointValueTarget(target_joint_positions);

  // Step 3
  moveit::planning_interface::MoveGroupInterface::Plan motion_plan_joints;
  bool joint_space_plan_success {planToJointSpaceGoal(target_joint_positions, motion_plan_joints)};

  // Step 4
  if (joint_space_plan_success)
    move_group_interface_->execute(motion_plan_joints);

  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * EXAMPLE 2 - Move the robot through end-effector waypoints to draw a triangle.
   *
   * Step 1: Define waypoints for the end-effector - A vector of pose messages.
   * Step 2: Add the current end-effector pose as the first waypoint.
   * Step 3: Add the remaining waypoints relative to the first waypoint.
   * Step 4: Define an empty message to store the trajectory generated by planner.
   * Step 5: Plan the path.
   * Step 6: Move the robotic arm!
   */
  RCLCPP_INFO(this->get_logger(), "Example 2");

  // Step 1
  std::vector<geometry_msgs::msg::Pose> waypoints;

  // Step 2
  auto current_pose = move_group_interface_->getCurrentPose().pose;
  waypoints.push_back(current_pose);

  double triangle_side {0.25};

  // Step 3
  auto pose1 = current_pose;
  pose1.position.z += std::sqrt(3) * 0.25 * triangle_side;
  waypoints.push_back(pose1);

  auto pose2 = pose1;
  pose2.position.z -= std::sqrt(3) * 0.5 * triangle_side;
  pose2.position.y += 0.5 * triangle_side;
  waypoints.push_back(pose2);

  auto pose3 = pose2;
  pose3.position.y -= triangle_side;
  waypoints.push_back(pose3);

  auto pose4 = pose3;
  pose4.position.z += std::sqrt(3) * 0.5 * triangle_side;
  pose4.position.y += 0.5 * triangle_side;
  waypoints.push_back(pose4);

  auto pose5 = pose4;
  pose5.position.z -= std::sqrt(3) * 0.25 * triangle_side;
  waypoints.push_back(pose5);

  // Step 4
  moveit_msgs::msg::RobotTrajectory cartesian_trajectory;

  // Step 5
  bool cartesian_plan_success {planCartesianPath(waypoints, cartesian_trajectory)};

  // Additional Step: Create and send a track request to start tracking the end-effector pose
  auto track_request {std::make_shared<lab8::srv::TrackRequest::Request>()};

  track_request->tf_root_frame_name = move_group_interface_->getPlanningFrame();
  track_request->tf_tip_frame_name = move_group_interface_->getEndEffectorLink();

  track_request->plot_title = "Example: A Triangle in the vertical plane";
  track_request->plot_axis_x = lab8::srv::TrackRequest::Request::Y_AXIS;
  track_request->plot_axis_y = lab8::srv::TrackRequest::Request::Z_AXIS;

  track_request->status = lab8::srv::TrackRequest::Request::START;

  bool track_request_success {sendEEFTrackRequest(track_request)};

  // Step 6
  if (cartesian_plan_success && track_request_success)
    move_group_interface_->execute(cartesian_trajectory);

  // Stop tracking the end effector by sending a STOP request.
  track_request->status = lab8::srv::TrackRequest::Request::STOP;
  sendEEFTrackRequest(track_request);

  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * EXAMPLE 3 - Move the robot to a specific end-effector pose.
   *
   * Step 1: Define a message that stores the target end-effector pose in world frame.
   * Step 2: Set the target end-effector pose message using either relative or absolute values.
   * Step 3: Set the target pose using the message.
   * Step 4: Move the robotic arm!
   */
  RCLCPP_INFO(this->get_logger(), "Example 3");

  // Step 1
  geometry_msgs::msg::Pose target_pose;

  // Step 2 - Setting the target displacement relative to current displacement. (Commented out for now)
  target_pose = move_group_interface_->getCurrentPose().pose;
  // target_pose.position.z += 0.05;
  // target_pose.position.y += 0.1;

  /**
   * Step 2 Continuation - Setting the target orientation relative to current orientation.
   *
   * Steps to rotate the end-effector by a certain value:
   * - Obtain the current orientation and convert it to TF2 Quaternion message
   * - Create an empty TF2 Quaternion message
   * - Set the rotation as desired using roll-pitch-yaw angles
   * - Apply the rotation by pre-multiplying with the current orientation quaternion
   * - Convert the TF2 quaternion message back to geometry message with the new
   *   orientation encoded into the target pose.
   *
   * In short, TF2 quaternions are used as an intermediate datatype to do
   * rotation math since geometry quaternions do not have that functionality.
   */
  tf2::Quaternion current_orientation_tf;
  tf2::convert(target_pose.orientation, current_orientation_tf);

  tf2::Quaternion desired_rotation_tf;
  desired_rotation_tf.setRPY(0, -M_PI_2, 0);

  auto target_orientation_tf = desired_rotation_tf * current_orientation_tf;
  tf2::convert(target_orientation_tf, target_pose.orientation);

  // Step 3
  move_group_interface_->setPoseTarget(target_pose);

  // Step 4
  move_group_interface_->move();

  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * EXAMPLE 4 - Moving the robot to a named, predefined position.
   *
   * All the predefined positions are defined in lab.srdf from the lab_moveit_config package in
   * joint space.
   */
  move_group_interface_->setNamedTarget("up");
  move_group_interface_->move();
}

void UR3eMoveInterface::drawCircleXY(double radius_meters)
{
  if (radius_meters <= 0)
    radius_meters = 0.45;

  waitForMoveGroupInterface();

  /// TODO: Move the arm into a pose to draw the shape by setting a joint-space target

  /// TODO: Set the points on the circle as waypoints and execute a Cartesian plan

  /// TODO: Move the robot back to its home position by setting a named target
}

void UR3eMoveInterface::drawCircleYZ(double radius_meters)
{
  if (radius_meters <= 0)
    radius_meters = 0.45;

  waitForMoveGroupInterface();

  /// TODO: Move the arm into a pose to draw the shape by setting a joint-space target

  /// TODO: Set the points on the circle as waypoints and execute a Cartesian plan

  /// TODO: Move the robot back to its home position by setting a named target
}

void UR3eMoveInterface::drawSquareXY(double side_meters)
{
  if (side_meters <= 0)
    side_meters = (0.45 * 2) / sqrt(2);

  waitForMoveGroupInterface();

  /// TODO: Move the arm into a pose to draw the shape by setting a joint-space target

  /// TODO: Set the corners of the square as waypoints and execute a Cartesian plan

  /// TODO: Move the robot back to its home position by setting a named target
}

void UR3eMoveInterface::drawSquareYZ(double side_meters)
{
  if (side_meters <= 0)
    side_meters = (0.45 * 2) / sqrt(2);

  waitForMoveGroupInterface();

  /// TODO: Move the arm into a pose to draw the shape by setting a joint-space target

  /// TODO: Set the corners of the square as waypoints and execute a Cartesian plan

  /// TODO: Move the robot back to its home position by setting a named target
}

void UR3eMoveInterface::waitForMoveGroupInterface()
{
  if (!move_group_interface_initialized_)
    RCLCPP_INFO(this->get_logger(), "Waiting for move group interface to initialize...");

  while(!move_group_interface_initialized_) {if (!rclcpp::ok()) return; };
}

bool UR3eMoveInterface::planToJointSpaceGoal(
  const std::vector<double>& target_joint_positions,
  moveit::planning_interface::MoveGroupInterface::Plan& motion_plan)
{
  bool within_bounds {move_group_interface_->setJointValueTarget(target_joint_positions)};

  if (!within_bounds) {
    RCLCPP_WARN_STREAM(this->get_logger(),
    "Some target joint positions were outside the limits. " <<
    "Generated motion plan will be clamped to the joint limits.");
  }

  bool plan_success {
    move_group_interface_->plan(motion_plan) == moveit::core::MoveItErrorCode::SUCCESS};

  if (plan_success)
    RCLCPP_INFO(this->get_logger(), "Plan to target joint positions succeeded");
  else
    RCLCPP_ERROR(this->get_logger(), "Plan to target joint positions failed");

  return plan_success;
}

bool UR3eMoveInterface::planToPoseGoal(
  const geometry_msgs::msg::Pose& pose_goal,
  moveit::planning_interface::MoveGroupInterface::Plan& motion_plan)
{
  move_group_interface_->setPoseTarget(pose_goal);

  bool plan_success {
    move_group_interface_->plan(motion_plan) == moveit::core::MoveItErrorCode::SUCCESS};

  if (plan_success)
    RCLCPP_INFO(this->get_logger(), "Plan to target end-effector pose succeeded");
  else
    RCLCPP_ERROR(this->get_logger(), "Plan to target end-effector pose failed");

  return plan_success;
}

bool UR3eMoveInterface::planToNamedTarget(
  const std::string& name,
  moveit::planning_interface::MoveGroupInterface::Plan& motion_plan) {

  move_group_interface_->setNamedTarget(name);

  bool plan_success {
    move_group_interface_->plan(motion_plan) == moveit::core::MoveItErrorCode::SUCCESS};

  if (plan_success)
    RCLCPP_INFO(this->get_logger(), "Plan to target end-effector pose succeeded");
  else
    RCLCPP_ERROR(this->get_logger(), "Plan to target end-effector pose failed");

  return plan_success;
}

bool UR3eMoveInterface::planCartesianPath(
  const std::vector<geometry_msgs::msg::Pose>& waypoints,
  moveit_msgs::msg::RobotTrajectory& trajectory)
{
  const double jump_threshold {0.0};
  const double eef_step {0.01};
  double fraction {
    move_group_interface_->computeCartesianPath(waypoints, eef_step, jump_threshold, trajectory)};

  RCLCPP_INFO_STREAM(this->get_logger(), "Planned cartesian path: " << fraction*100 << "%");

  bool plan_success {fraction*100 > 95.0};

  if (plan_success)
    RCLCPP_INFO(this->get_logger(), "Plan to follow a cartesian path succeeded");
  else
    RCLCPP_WARN_STREAM(this->get_logger(), "Couldn't fully achieve planned cartesian path");

  if (!plan_success)
    return plan_success;

  robot_trajectory::RobotTrajectory robot_trajectory {
    move_group_interface_->getCurrentState()->getRobotModel(), move_group_interface_->getName()};

  robot_trajectory.setRobotTrajectoryMsg(*move_group_interface_->getCurrentState(), trajectory);
  time_optimal_trajectory_generation_.computeTimeStamps(
    robot_trajectory,
    velocity_scaling_factor_, acceleration_scaling_factor_);
  robot_trajectory.getRobotTrajectoryMsg(trajectory);

  return plan_success;
}

bool UR3eMoveInterface::sendEEFTrackRequest(const lab8::srv::TrackRequest::Request::SharedPtr& request)
{
  if (!tracking_service_available_) {
    RCLCPP_WARN(
      this->get_logger(), "EEF tracking request send failed because this service is unavailable.");

    return false;
  }

  auto result_future {track_eef_client_->async_send_request(request).share()};

  RCLCPP_INFO(this->get_logger(), "EEF tracking request sent, waiting for result...");
  auto result_status {result_future.wait_for(std::chrono::seconds(1))};

  if (result_future.get()->success && result_status == std::future_status::ready)
    RCLCPP_INFO(this->get_logger(), "EEF tracking request success.");
  else
    RCLCPP_WARN(this->get_logger(), "EEF tracking request failed.");

  return result_future.get()->success;
}

int main(int argc, char** argv)
{
  std::string shape_argument {};
  std::string orientation_argument {};
  std::string size_argument {};

  if (argv[1])
    shape_argument = argv[1];

  if (argv[2])
    orientation_argument = argv[2];

  if (argv[3])
    size_argument = argv[3];

  double size {};
  try {
    size = std::stod(size_argument);
  }
  catch (std::exception& exception) {
    std::cout << '\n' << "A valid size value isn't given, default will be used instead." << '\n'
              << '\n';
    size = 0;
  }

  rclcpp::init(argc, argv);

  rclcpp::NodeOptions node_options;
  node_options.automatically_declare_parameters_from_overrides(true);
  auto mover_node {std::make_shared<UR3eMoveInterface>(node_options)};

  rclcpp::executors::SingleThreadedExecutor executor;
  executor.add_node(mover_node);
  std::thread([&executor]() { executor.spin(); }).detach();

  if (shape_argument == "circle" && orientation_argument == "horizontal")
    mover_node->drawCircleXY(size);

  else if (shape_argument == "circle" && orientation_argument == "vertical")
    mover_node->drawCircleYZ(size);

  else if (shape_argument == "square" && orientation_argument == "horizontal")
    mover_node->drawSquareXY(size);

  else if (shape_argument == "square" && orientation_argument == "vertical")
    mover_node->drawSquareYZ(size);

  else
    mover_node->examplesMoveIt();

  rclcpp::shutdown();

  return 0;
}
