#include "lab7/ur3e_mover.hpp"

UR3eMover::UR3eMover(const std::string& planning_group_name)
  : Node("ur3e_mover"),
    move_group_(rclcpp::Node::SharedPtr(std::move(this)),
                planning_group_name)
{
  examplesMoveIt();
}

void UR3eMover::examplesMoveIt()
{
  /**
   * Based on MoveIt Documentation - Move Group C++ Interface
   *
   * Use the content inside this function as a reference and learn about using
   * the MoveGroup Interface to move the UR3e manipulator.
   *
   * MoveIt! API lets you move the robotic arm in three ways:
   *  - By commanding target joint angles
   *  - By commanding waypoints through which the end-effector has to go
   *  - By commanding a pose target of the end-effector
   *
   * Use these methods to draw shapes with the robotic arm.
   */

  RCLCPP_INFO(this->get_logger(), "Running examples...");


  // EXAMPLE 1 - Move the robot to specific joint positions. -------------------

  // Define a vector of doubles to specify your joint positions in radians.
  std::vector<double> target_joint_positions {M_PI_2, -M_PI_2, M_PI_2, -M_PI,
                                              -M_PI_2, 0};

  // Step 2: Set the target joint angles to the arm.
  move_group_.setJointValueTarget(target_joint_positions);

  // Step 3: Define an empty motion plan message that stores the trajectory
  // generated by the planner.
  moveit::planning_interface::MoveGroupInterface::Plan motion_pain_joints;

  // Step 4: Plan the motion to target joint angles.
  move_group_.plan(motion_pain_joints);

  // Step 5: Move the robotic arm!
  move_group_.move();


  // EXAMPLE 2 - Move the robot through end-effector waypoints  ----------------
  //             to draw a triangle.

  // Step 1: Define waypoints for the end-effector - A vector of pose messages
  std::vector<geometry_msgs::msg::Pose> waypoints;

  // Step 2: Add the current end-effector pose as the first waypoint.
  auto current_pose = move_group_.getCurrentPose().pose;
  waypoints.push_back(current_pose);

  // Step 3: Add the remaining waypoints relative to the first waypoint
  auto pose1 = current_pose;
  pose1.position.x -= 0.1;
  waypoints.push_back(pose1);

  auto pose2 = pose1;
  pose2.position.y -= 0.1;
  waypoints.push_back(pose2);

  auto pose3 = pose2;
  pose3.position.x += 0.1;
  pose3.position.y += 0.1;
  waypoints.push_back(pose3);

  // Step 4: Define an empty message to store the trajectory generated by planner
  moveit_msgs::msg::RobotTrajectory cartesian_trajectory;

  // Step 5: Plan the path
  move_group_.computeCartesianPath(waypoints, 0.01, 0.05, cartesian_trajectory);

  // Step 6: Move the robotic arm!
  move_group_.execute(cartesian_trajectory);


  // EXAMPLE 3 - Move the robot to a specific end-effector pose. ---------------

  /**
   * Step 1:
   *
   * Define a message with the desired end-effector pose in world frame.
   *
   * The message can be defined directly but realistically it's easier to define
   * relative to current end-effector pose.
   */
  geometry_msgs::msg::Pose target_pose;

  // Get the current end-effector pose
  target_pose = move_group_.getCurrentPose().pose;

  // Provide relative displacements from the current pose
  target_pose.position.z += 0.1;

  /**
   * Steps to rotate the end-effector:
   * - Create an empty TF2 Quaternion message
   * - Set the rotation as desired using roll-pitch-yaw angles
   * - Apply the rotation by pre-multiplying with the current orientation quaternion
   * - Convert the TF2 quaternion message to geometry message with the new
   *   orientation encoded into the target pose.
   *
   * In short, TF2 quaternions are used as an intermediate datatype to do
   * rotation math since geometry quaternions do not have that functionality.
   */
  tf2::Quaternion desired_rotation_tf;
  desired_rotation_tf.setRPY(0, -M_PI_2, 0);

  tf2::Quaternion current_orientation_tf;
  tf2::convert(target_pose.orientation, current_orientation_tf);
  auto target_orientation_tf = desired_rotation_tf * current_orientation_tf;

  tf2::convert(target_orientation_tf, target_pose.orientation);

  // Step 2: Set the pose target to the arm
  move_group_.setPoseTarget(target_pose);

  // Step 3: Define an empty motion plan message that stores the trajectory
  // generated by the planner.
  moveit::planning_interface::MoveGroupInterface::Plan motion_pain_pose;

  // Step 4: Plan the motion to target end-effector pose
  move_group_.plan(motion_pain_pose);

  // Step 5: Move the robotic arm!
  move_group_.move();
}

void UR3eMover::planToJointSpaceGoal(
  const std::vector<double>& target_joint_positions,
  moveit::planning_interface::MoveGroupInterface::Plan& motion_plan)
{
  bool within_bounds {move_group_.setJointValueTarget(target_joint_positions)};

  if (!within_bounds) {
    RCLCPP_WARN_STREAM(this->get_logger(),
    "Some target joint positions were outside the limits. " <<
    "Generated motion plan will be clamped to the joint limits.");
  }

  bool plan_success {
    move_group_.plan(motion_plan) == moveit::core::MoveItErrorCode::SUCCESS};

  if (plan_success)
    RCLCPP_INFO(this->get_logger(), "Plan to target joint positions succeeded");
  else
    RCLCPP_WARN(this->get_logger(), "Plan to target joint positions failed");
}

void UR3eMover::planToPoseGoal(
  const geometry_msgs::msg::Pose& pose_goal,
  moveit::planning_interface::MoveGroupInterface::Plan& motion_plan)
{
  move_group_.setPoseTarget(pose_goal);

  bool plan_success {
    move_group_.plan(motion_plan) == moveit::core::MoveItErrorCode::SUCCESS};

  if (plan_success)
    RCLCPP_INFO(this->get_logger(), "Plan to target end-effector pose succeeded");
  else
    RCLCPP_WARN(this->get_logger(), "Plan to target end-effector pose failed");
}

void UR3eMover::planCartesianPath(
  const std::vector<geometry_msgs::msg::Pose>& waypoints,
  moveit_msgs::msg::RobotTrajectory& trajectory)
{
  const double jump_threshold {0.0};
  const double eef_step {0.01};
  double fraction {move_group_.computeCartesianPath(waypoints,
                                                    eef_step,
                                                    jump_threshold,
                                                    trajectory)};

  RCLCPP_INFO_STREAM(this->get_logger(), "Planned cartesian path: "
                     << fraction*100 << "%");

  if (fraction*100 < 95.0) {
    RCLCPP_WARN_STREAM(this->get_logger(), "Couldn't fully achieve planned " <<
                       "cartesian path, try again.");
  }
}

void UR3eMover::drawCircleXY(double radius_meters)
{
  if (radius_meters <= 0)
    radius_meters = 0.45;

  // TODO: Write the function to draw a circle on the XY plane for a given radius
  //       using the methods from MoveIt! API.
}

void UR3eMover::drawCircleYZ(double radius_meters)
{
  if (radius_meters <= 0)
    radius_meters = 0.45;

  // TODO: Write the function to draw a circle on the XZ plane for a given radius
  //       using the methods from MoveIt! API.
}

void UR3eMover::drawSquareXY(double side_meters)
{
  if (side_meters <= 0)
    side_meters = (0.45 * 2) / sqrt(2);

  // TODO: Write the function to draw a square on the XY plane for a given side
  //       length using the methods from MoveIt! API.
}

void UR3eMover::drawSquareYZ(double side_meters)
{
  if (side_meters <= 0)
    side_meters = (0.45 * 2) / sqrt(2);

  // TODO: Write the function to draw a square on the XZ plane for a given side
  //       length using the methods from MoveIt! API.
}
